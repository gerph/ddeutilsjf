In   -
Out  Prefix
Type Module

Define Workspace
 Name      module
 Default   r12
  `prefixlist    !   linked list of prefixes

 Name      prefix
 Default   r5
  `next          !   the next entry
  `last          !   make it doubly linked for easy !
  `domain        !   the domain it's in
  `prefix        !   pointer to the prefix string
End Workspace

Define Module
 Name      Prefix
 Author    Justin Fletcher
 Commands
  Name     MPrefix
  Code     com_prefix
  Max      1
  Min      0
  Help     ...
           *Prefix sets the current directory for the current context. Used
           with no parameters it resets the current directory to the global
           value.
  Syntax   Syntax: *Prefix [<directory>]

  Name     Prefixes
  Code     com_prefixes
  Help     *Prefixes lists prefixes currently defined.
 End commands
 Vectors
  FileV      filev
  GBPBV      gbpbv
  FindV      findv
  FSControlV fscontrolv
 End Vectors
 Services
  WimpCloseDown  wimp_closedown
 End Services
 SWIs
  Prefix     Prefix
  Base       &425C0
   0         Prefix    swi_prefix
 End SWIs
 Workspace *`len_module
End Module

Pre
 LIBRARY "VersionBas":PROCinit_version
 module_version$=version_major$
 module_date$=version_date$
End Pre

#Rem off
>findv
   B       replacevars                   ; OS_Find
>fscontrolv
   TEQ     r0,#2                         ; is it 2 (New app starting) ?
   TEQNE   r0,#4                         ; or 4 (*Run file) ?
   MOVEQ   pc,link                       ; return if so
   TEQ     r0,#0                         ; is it set csd ?
   ORREQ   r12,r12,#1                    ; if so, mark us as being 'special'
   B       replacevars                   ; call replacement OS_FSControl

>gbpbv
   B       replacevars                   ; OS_GBPB
>filev
   B       replacevars                   ; OS_File

>wimp_closedown
   TEQ     r0,#0                         ; is it a 'real' closedown ?
   MOVNES  pc,link                       ; return if not
   STMFD   (sp)!,{r0,link}               ; Stack registers
   XBL     swi_prefix,0                  ; unset the prefix if one
   LDMFD   (sp)!,{r0,pc}^                ; Return from call

; *******************************************************************
; Subroutine:   swi_prefix
; Description:  Sets the prefix for the current directory (or unsets
;               it)
; Parameters:   r0-> prefix name, or "" or 0 to unset
; Returns:      with error if can't do it
; *******************************************************************
>swi_prefix
   STMFD   (sp)!,{r0-r5,link}            ; Stack registers
   MOV     r3,r0                         ; r3-> string
   CMP     r0,#0                         ; is r0 = 0 ?
   LDRNEB  r4,[r0]                       ; if not read first byte of r0
   CMPNE   r4,#32                        ; is it <32 ?
   MOVLE   r4,#0                         ; if either, no args
   MOVGT   r4,#1                         ; else, r4 = 1 arg
; r3-> args, r4 = 0 for no args (unset), 1 for 1 arg (set)
;    REM     " *Prefix %$3 (%r4)"
   LMOV    r0,#&FF8                      ; address of domain Id
   LDR     r1,[r0]                       ; read our domain id
   LDRW    r5,`prefixlist                ; read list
   RAS     r5,r1,#`domain                ; create the list entry
   CMP     r5,#0                         ; is it valid ?
   BEQ     $createanew                   ; nope, so we create one specially
   LDRW    r0,`prefix                    ; re-read the prefix
   BL      release                       ; free the string
   B       $created                      ; now let's deal with it...

$createanew
   XBL     claim,`len_prefix             ; claim space for the block
   LDRW    r5,`prefixlist                ; read top of prefix list
   CMP     r5,#0                         ; is it 'valid' ?
   STRWNE  r0,`last                      ; store us as their 'last' pointer
   STRW    r0,`prefixlist                ; we are the head of the prefix list
   STR     r5,[r0,#`next]                ; link the list to us
   MOV     r5,r0                         ; r5-> block
   MOV     r0,#0                         ; null the 'last' pointer
   STRW    r0,`last                      ; store it
$created
;    REM     "Created entry, r5->%&5"
   CMP     r4,#0                         ; did they give any params ?
   BEQ     $deleteentry                  ; nope, so delete prefix
   BL      docanonicalisation            ; canonicalise it
   STRW    r0,`prefix                    ; store our prefix
   STRW    r1,`domain                    ; store our domainid
   LDMFD   (sp)!,{r0-r5,pc}              ; Return from call

$deleteentry
   LDRW    r1,`last                      ; read 'last' pointer
   LDRW    r2,`next                      ; read 'next' pointer
   CMP     r1,#0                         ; is 'last' 0 ? (at head)
   STRWEQ  r2,`prefixlist                ; if so, store next as 'head'
   STRNE   r2,[r1,#`next]                ; otherwise, link it to us
   CMP     r2,#0                         ; is 'next' 0 ? (at tail)
   STRNE   r1,[r2,#`last]                ; if not, store our 'back' link
   XBL     release,r5                    ; free 'us'
;    REM     "Freed"

   LDMFD  (sp)!,{r0-r5,pc}               ; Return from call

; *******************************************************************
; Subroutine:   com_prefixes
; Description:  Display the prefixes currently set
; Parameters:   r12-> private word (not = private word!)
; Returns:      none
; *******************************************************************
>com_prefixes
   STMFD   (sp)!,{r0-r5,link}            ; Stack registers
   LDR     r12,[r12]                     ; read our workspace
   LDRW    r5,`prefixlist                ; read head of list
$loop
   CMP     r5,#0                         ; done ?
   BEQ     $done
   LDRW    r0,`next                      ; read next
   LDRW    r1,`last                      ; read last
   LDRW    r2,`domain                    ; read domainid
   LDRW    r3,`prefix                    ; read prefix
   LDRB    r4,[r3],#4                    ; r4 = length of 'fs'
   ADD     r4,r4,r3                      ; add on to base
   ADD     r4,r4,#1                      ; skip terminator
   REMP    "This=%&5, Next=%&0, Last=%&1"
   REMP    "Domain=%&2, FS=%$3, CSD=%$4"
   MOV     r5,r0                         ; this=next
   B       $loop                         ; and go some more
$done
   LDMFD   (sp)!,{r0-r5,pc}              ; Return from call

; *******************************************************************
; Subroutine:   com_prefix
; Description:  Sets the current prefix
; Parameters:   r0 = cli
; Returns:      none
; *******************************************************************
>com_prefix
   STMFD   (sp)!,{r0-r5,link}            ; Stack registers
   LDR     r12,[r12]                     ; read our workspace
   BL      swi_prefix                    ; process it (quickly?)
   LDMFD   (sp)!,{r0-r5,pc}              ; Return from call

; *******************************************************************
; Subroutine:   docanonicalisation
; Description:  Canonicalise, claim space for, and return result in
;               r0
; Parameters:   r3-> thing to canonicalise
; Returns:      r0-> new strdup'd string
; *******************************************************************
>docanonicalisation
   STMFD   (sp)!,{r1-r5,link}            ; Stack registers
   XSWI    "XOS_FSControl",37,r3,0,0,0,0 ; find it's length
   RSB     r5,r5,#0                      ; r5=length needed
   ADD     r5,r5,#1                      ; add on one for terminator
   ADD     r0,r5,#4                      ; add on 'fs len space'
   XBL     claim                         ; claim that much
;    TEQ     r0,#0                         ; check enough space (N/A)
   ADD     r2,r0,#4                      ; r2-> buffer for result
   XSWI    "XOS_FSControl",37,,,0,0      ; decode it to buffer
;    REM     "Canonicalised to %$2, returned r5=%r5"
   MOV     r1,#0                         ; 0 bytes into it
$findcolonloop
   LDRB    r0,[r2,r1]                    ; read a byte
   CMP     r0,#32                        ; is it 'term' ?
   MOVEQ   r1,#0                         ; if so, the string is 0 long
   BEQ     $found                        ; and pretend we found it
   CMP     r0,#ASC(":")                  ; is it a colon ?
   ADDNE   r1,r1,#1                      ; if not, next char
   BNE     $findcolonloop                ; and go around more
$found
   MOV     r3,#0                         ; terminate at it
   STRB    r3,[r2,r1]                    ; store over the colon
   STRB    r1,[r2,#-4]!                  ; store the length and decrment
   ADD     r0,r2,r1                      ; r0-> terminator
   ADD     r0,r0,#1                      ; r0-> after terminator
   XBL     strlen                        ; find strlen
   STRB    r1,[r2,#1]                    ; store at offset 1
   MOV     r0,r2                         ; r0-> block
   LDMFD   (sp)!,{r1-r5,pc}              ; Return from call

; *******************************************************************
; Subroutine:   replacevars
; Description:  Replaces FS$CurrentFS and FS$<currentfs>$csd for the
;               duration of the call, then restores them afterwards
; Parameters:   as vector
; Returns:      as vector, having postprocessed it
; *******************************************************************
>replacevars
   STMFD   (sp)!,{r0-r10,link}           ; Stack registers
; check 'special' markers
   TST     r12,#3                        ; is b0 or b1 set in ws ?
   AND     r9,r12,#3                     ; r9='marker'
   BICNE   r12,r12,#3                    ; clear it if so

   LDRW    r10,`prefixlist               ; r10-> our list
   LMOV    r0,#&FF8                      ; address of domain Id
   LDR     r0,[r0]                       ; read our domain id
   RAS     r10,r0,#`domain               ; find if it's in the list
   TEQ     r10,#0                        ; did we find it

;    STRNE   r10,[r10,#`domain]            ; kill the next recurrance

$nothingdone
   LDMEQFD (sp)!,{r0-r10,pc}             ; nope, so return nicely
; find len of CurrentFilingSystem
   XSWI    "XOS_ReadVarVal",^$`fscsfs,-1,-1,0,0 ; find len of current fs
   TEQ     r2,#0                         ; was there a variable ?
   MOVEQ   r8,#0                         ; if none, no current fs
   BEQ     $gotoldfs
   RSB     r2,r2,#0                      ; r0=length to claim
   ADD     r2,r2,#1                      ; 1 more, to be sure !
   XBL     claim,r2                      ; claim it
   TEQ     r0,#0                         ; did it work ?
   BEQ     $nothingdone                  ; if not, we failed - abort !
   MOV     r8,r0                         ; r8-> fs
; read CurrentFilingSystem
   XSWI    "XOS_ReadVarVal",^$`fscsfs,r8,,0,0 ; read current fs
   MOV     r0,#0
   STR     r0,[r8,r2]                    ; store terminator after string
$gotoldfs
   MOV     r0,#(fscsd_leftlen+fscsd_rightlen+1) ; base length of string
   LDR     r4,[r10,#`prefix]             ; read pointer to prefix
   LDRB    r4,[r4,#0]                    ; read length of FS
   ADD     r2,r4,#1                      ; add one for luck
   ADD     r0,r0,r2                      ; add on the number of bytes read
   BL      claim                         ; claim space for variable name
   TEQ     r0,#0                         ; did it fail ?
   BEQ     $nothingdone                  ; if so, panic !
   MOV     r6,r0                         ; r6-> csd variable name
   MOV     r1,#fscsd_leftlen             ; r1 = len to copy
   ADR     r3,$`fscsd_left               ; address to copy from
$leftloop
   SUBS    r1,r1,#1                      ; go down by one
   BMI     $leftdone                     ; if -ve, we're done
   LDRB    r2,[r3,r1]                    ; read byte
   STRB    r2,[r6,r1]                    ; store in new buffer
   B       $leftloop                     ; and do again
; copied the left side
$leftdone
   LDR     r0,[r10,#`prefix]             ; read pointer to prefix data
   ADD     r0,r0,#4                      ; skip the fs len, r0-> fs
   ADD     r1,r6,#fscsd_leftlen          ; add on leftlen (-> fsname)
   XBL     strcpy,,r1                    ; copy it on
   ADD     r1,r1,r4                      ; add on fslen
   XBL     strcpy,^$`fscsd_right         ; and the right side
; read csd var len
   XSWI    "XOS_ReadVarVal",r6,-1,-1,0,0 ; find length of it's var
   TEQ     r2,#0                         ; was there a variable ?
   MOVEQ   r7,#0                         ; if none, no current directory
   BEQ     $gotblks
; now read val itself
   RSB     r2,r2,#0                      ; r0=length to claim
   ADD     r2,r2,#2                      ; 1 more, to be sure !
   XBL     claim,r2                      ; claim it
   TEQ     r0,#0                         ; did it work ?
   BEQ     $nothingdone                  ; if not, we failed - abort !
   MOV     r7,r0                         ; r7-> fs value
   XSWI    "XOS_ReadVarVal",r6,r7,,0,0   ; read current fs
   MOV     r0,#0
   STRB    r0,[r7,r2]                    ; store terminator after string
$gotblks ; temporary until we're got it working
   REM     "FS was %$8"
   REM     "FSCSD Var = %$6"
   REM     "FSCSD = %$7"
; now to set the vars
   LDR     r5,[r10,#`prefix]             ; read pointer to prefix block
   LDRB    r2,[r5,#0]                    ; read length of FS
   ADD     r1,r5,#4                      ; r1-> value to set
   REM     "Setting FS to %$1"
   XSWI    "XOS_SetVarVal",^$`fscsfs,,,0,0 ; set current fs
   LDRB    r2,[r5,#0]                    ; read length of FS
   ADD     r1,r5,r2                      ; r1-> value to set
   ADD     r1,r1,#5                      ; skip the 'length' data
   LDRB    r2,[r5,#1]                    ; read length of csd
   REM     "Setting CSD to %$1"
   XSWI    "XOS_SetVarVal",r6,,,0,0      ; set csd
; now to pass on to original caller
   LDMFD   (sp)!,{r0-r5}                 ; restore 'normal' registers
   STMFD   (sp),{r6,r7,r8,r9}            ; stack 'our' registers (nowb)
   LDMFD   (sp),{r6-r10}                 ; re-read old registers
   SUB     sp,sp,#4*4                    ; move down to our bottom of stack
; on stack now, r6,r7,r8,r9,or6,or7,or8,or9,or10,return to address
   STMFD   (sp)!,{pc}                    ; store our pc so we know we return
   ADD     r12,sp,#4*10                  ; read return point
   LDMFD   r12,{pc}                      ; return there

; we drop to here on return
   STMFD   (sp)!,{r0-r9,pc}              ; stack regs 0-8 and pc
   MOV     r0,pc                         ; r0=pc
   REM     "Called on exit"
   ADD     r5,sp,#4*11                   ; skip the registers we just stacked
   LDMIA   r5,{r6,r7,r8,r9}              ; re-read the regs we hung on to
; r6-> csd var, r7-> csd, r8-> csfs, r9= 'special' marker
; first perform special functions
   TEQ     r9,#1                         ; is it 'set csd' ?
   BNE     $notspecial                   ; if not, skip this
   TST     r0,#vbit                      ; is v set (was there an error) ?
   BNE     $notspecial                   ; if error, abort
   XSWI    "XPrefix_Prefix",^$`thisdir   ; call the swi marking new dir
$notspecial
; restore current filing system
   CMP     r8,#0                         ; is csfs 0 ?
   XBLNE   strlen,r8                     ; if not, read it's length
   MVNEQ   r2,#NOT -1                    ; if so, use -1 to delete
   MOVNE   r2,r1                         ; otherwise, r2=length
   REM     "Restoring FS %$8"
   XSWI    "XOS_SetVarVal",^$`fscsfs,r8,,0,0 ; set it (restore current fs)
; restore csd variable
   CMP     r7,#0                         ; is csd 0 ?
   XBLNE   strlen,r7                     ; if not, read it's length
   MVNEQ   r2,#NOT -1                    ; if so, use -1 to delete
   MOVNE   r2,r1                         ; otherwise, r2=length
   REM     "Restoring CSD %$7"
   XSWI    "XOS_SetVarVal",r6,r7,,0,0    ; set it (restore csd)
; now return nicely
   REM     "Returning"
   LDMFD   (sp)!,{r0-r9,link}            ; restore registers
   ADD     sp,sp,#4*10                   ; add on the 9 regs to skip
   TST     link,#vbit                    ; was v set
   LDMFD   (sp)!,{link}                  ; re-read link
   ORRNES  pc,link,#vbit                 ; if so, return with vset
   BICEQS  pc,link,#vbit                 ; else, don't

$`thisdir
   EQUZA   "@"
$`fscsfs
%fscsd_leftlen=LEN("FileSwitch$")
%fscsd_rightlen=LEN("$CSD")
$`fscsd_left
   EQUZA   "FileSwitch$CurrentFilingSystem"
$`fscsd_right
   EQUZA   "$CSD"

#Library "Memory",claim.release.strdup
#Library "Strings",strlen.strcpy
#Here Libraries
#Post
#Run <CODE>
