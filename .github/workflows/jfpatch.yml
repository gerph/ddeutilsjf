---
# RISC OS CI build through JFPatch as a service.
#
# To reuse this configuration with your own repository:
#
#   - Create a .robuild.yaml to describe what should be built on RISC OS.
#       - `jobs.build.script` should be a list of commands to run on RISC OS
#       - `jobs.build.artifacts.path` should be the directory to zip.
#   - Create a VersionNum file if you wish to use the automated versioning
#     in the same style as the RISC OS sources. [optional]
#   - Update the 3rd step ('give the archive a versioned name') to give a
#     suitable name for the archive.
#   - Update the 4th step ('upload-artifacts') to include the same names.
#

name: RISC OS

# Controls when the action will run. Triggers the workflow on:
#   * push or pull request on any branch.
#   * tag creation for tags beginning with a 'v'
on:
  push:
    branches: ["*"]
  pull_request:
    branches: ["*"]
  create:
    tags:
      - v*

jobs:
  build-riscos:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    outputs:
      version: ${{ steps.version.outputs.version }}
      leafname: ${{ steps.version.outputs.leafname }}

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      # Step intended to be reused in CI pipelines.
      - name: Build through JFPatch-as-a-service
        run: |
          set -o pipefail
          mkdir /tmp/robuild
          # Zip up the source to send to robuild
          zip -q9r /tmp/source-archive.zip * .robuild.yaml
          # Send the archive file to JFPatch as a service
          curl -q -F 'source=@/tmp/source-archive.zip' -o /tmp/robuild/result.json https://json.build.riscos.online/build/json
          # Extract any system messages and output
          jq -r '.messages[]' /tmp/robuild/result.json > /tmp/robuild/messages.txt || \
            { echo "Server response:" ; cat /tmp/robuild/result.json ; false ; }
          jq -r 'reduce .output[] as $i ("";. + $i)' /tmp/robuild/result.json > /tmp/robuild/output.txt
          # Extract return code
          rc=$(jq -r .rc /tmp/robuild/result.json | tee /tmp/robuild/rc.json)
          # Marker files for the state
          if [ "$rc" != "0" ] ; then touch /tmp/robuild/failed ; else touch /tmp/robuild/ok ; fi
          # Extract the built binary if we had any
          if [ "$rc" = "0" ] ; then
              jq -r .data /tmp/robuild/result.json | base64 --decode - > /tmp/robuild/built
          fi
      # Outputs:
      #   /tmp/robuild/result.json    - JSON output from the service.
      #   /tmp/robuild/{ok,failed}    - status of the build (whether RC was 0).
      #   /tmp/robuild/built          - the output result from the build.
      #   /tmp/robuild/rc             - the value of the return code (decimal string)
      #   /tmp/robuild/messages.txt   - system messages
      #   /tmp/robuild/output.txt     - output from the build

      # Another drop in, which uses that information to show the results
      - name: Did it work?
        run: |
          echo "System messages:"
          sed 's/^/  /' < /tmp/robuild/messages.txt
          echo
          echo "Build output:"
          sed 's/^/  /' < /tmp/robuild/output.txt
          echo
          if [ ! -f /tmp/robuild/ok ] ; then
              echo "FAILED! Aborting"
              exit 1
          fi

      - name: Give the output a versioned name
        id: version
        run: |
          if [[ -f VersionNum ]] ; then
              version=$(sed '/MajorVersion / ! d ; s/.*MajorVersion *"\(.*\)"/\1/' VersionNum)
          else
              version=$(git rev-parse --short HEAD)
          fi
          echo "This is version: $version"
          leafname="DDEUtils-$version.zip"
          if [ -f /tmp/robuild/built ] ; then
              cp /tmp/robuild/built "/tmp/robuild/$leafname"
          else
              echo "No archive was built?"
              exit 1
          fi
          echo "::set-output name=version::$version"
          echo "::set-output name=leafname::$leafname"

      - uses: actions/upload-artifact@v2
        with:
          name: RISCOS-build
          path: /tmp/robuild/${{ steps.version.outputs.leafname }}
        # The artifact that is downloadable from the Actions is actually a zip of the artifacts
        # that we supply. So it will be a regular Zip file containing a RISC OS Zip file.

  # The release only triggers when the thing that was pushed was a tag starting with 'v'
  release:
    needs: build-riscos
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Download built binary
        uses: actions/download-artifact@v1
        with:
          name: RISCOS-build

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ needs.build-riscos.outputs.version }}
          draft: true
          prerelease: false

      - name: Upload Release Asset
        id: upload-release-asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`.
          # See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps 
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: RISCOS-build/${{ needs.build-riscos.outputs.leafname }}
          asset_name: ${{ needs.build-riscos.outputs.leafname }}
          asset_content_type: application/zip
